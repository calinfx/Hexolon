<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automata Geometry Coder V5.0.0</title>
    <!-- Load Three.js core library and necessary modules directly from a reliable CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/jsm/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/jsm/exporters/USDZExporter.js"></script>
    
    <style>
        /* Mobile-first CSS adhering to your preferred desert/fantasy aesthetic */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            background-color: #3d312f; /* Dark Brown/Coffee Color */
            color: #d8c6b7; /* Light Desert Sand Text */
        }
        #app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #header {
            padding: 1rem;
            background-color: #5d3f6a; /* Richer Purple */
            color: #ffcc66; /* Orange-Yellow accent */
            text-align: center;
        }
        #scene-container {
            flex-grow: 1;
            width: 100%;
            touch-action: none;
            position: relative;
            background-color: #2b211f; /* Darker than body for contrast */
        }
        #controls {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #4f3b39;
            gap: 10px;
        }
        .btn {
            background-color: #8A2BE2; /* Primary Purple */
            color: white;
            padding: 0.8rem 1.6rem;
            border-radius: 10px; /* Rounded corners */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            width: 90%;
            max-width: 350px;
            box-shadow: 0 4px #5e1a9e; 
            border: 2px solid #ffaa00; /* Orange border */
        }
        .btn:hover {
            background-color: #791bd0;
            transform: translateY(-1px);
        }
        .btn:active {
            box-shadow: 0 2px #5e1a9e;
            transform: translateY(1px);
        }
        .status-box {
            margin-top: 5px;
            padding: 10px;
            border-radius: 8px;
            background-color: #1f2937;
            text-align: center;
            width: 90%;
            max-width: 350px;
            color: #f3f4f6;
            font-size: 0.9rem;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <header id="header">
            <div id="version-tag" style="font-size: 1.1rem; font-weight: 700;">Automata Geometry Coder (V5.0.0)</div>
        </header>

        <!-- The 3D scene container -->
        <div id="scene-container">
            <!-- Three.js Canvas will be injected here -->
        </div>

        <!-- Controls Panel -->
        <div id="controls">
            <button id="export-button" class="btn">
                Code & Export Geometry (.usdz)
            </button>
            <div id="export-status" class="status-box" style="background-color: #6a4c9c; color: #fff;">
                Loading 3D scene...
            </div>
            
        </div>
    </div>

    <script>
        // Global variables for Three.js elements
        let scene, camera, renderer, controls;
        let robotArmGroup; 
        const clock = new THREE.Clock();

        // --- Configuration ---
        // Your preferred colors for the machinery
        const PRIMARY_COLOR = 0x8A2BE2; // Purple
        const ACCENT_COLOR_A = 0x00CED1; // Dark Turquoise
        const ACCENT_COLOR_B = 0xFFA500; // Orange
        const BASE_COLOR = 0x8B4513; // Saddle Brown
        const GREEN_BRICK_COLOR = 0x3CB371; // Medium Sea Green (The "Green Brick")
        
        function init() {
            // Check for required Three.js components before proceeding
            if (!window.THREE || typeof THREE.OrbitControls === 'undefined' || typeof THREE.USDZExporter === 'undefined') {
                 document.getElementById('export-status').textContent = 'ERROR: Required scripts are missing. Check console.';
                 document.getElementById('export-status').style.backgroundColor = '#cc4444'; // Red error color
                 document.getElementById('export-status').style.color = '#fff';
                 return;
            }

            const container = document.getElementById('scene-container');
            const statusBox = document.getElementById('export-status');
            
            // 1. Setup Scene and Renderer
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2b211f); // Scene background matching container

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // 2. Setup Camera (Closer view for mobile)
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(2.5, 3.5, 4.5); 
            camera.lookAt(0, 1.5, 0);

            // 3. Lighting (Bright ambient light and directional light)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); 
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffcc66, 1.5); // Orange-Yellow Light
            directionalLight.position.set(5, 10, 5);
            directionalLight.target.position.set(0, 0, 0);
            scene.add(directionalLight);
            scene.add(directionalLight.target);

            // 4. Create the complex machinery geometry
            createAutomataAltar();

            // 5. Setup Orbit Controls for touch/mouse interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 15;

            // 6. User Interface Elements
            document.getElementById('export-button').addEventListener('click', handleUSDZExport);
            statusBox.textContent = '3D Scene Ready. Drag to rotate.';
            statusBox.style.backgroundColor = '#3CB371'; // Green Ready Color
            statusBox.style.color = '#1f2937';

            // 7. Handle window resizing
            window.addEventListener('resize', onWindowResize, false);
            
            // 8. Start the animation loop
            animate();
        }

        function createAutomataAltar() {
            // 1. Foundation (Saddle Brown)
            const baseGeometry = new THREE.CylinderGeometry(2, 2.5, 0.6, 32); 
            const baseMaterial = new THREE.MeshStandardMaterial({ color: BASE_COLOR, metalness: 0.1, roughness: 0.8 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.3; // Raised slightly above y=0
            scene.add(base);

            // 2. Central Altar Tower (Purple/Turquoise)
            const towerGroup = new THREE.Group();
            
            const coreGeometry = new THREE.BoxGeometry(1.0, 3.5, 1.0); 
            const coreMaterial = new THREE.MeshStandardMaterial({ color: PRIMARY_COLOR, metalness: 0.6, roughness: 0.4 });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = 2.0; // Centered vertically on the base
            towerGroup.add(core);

            // Glowing Alien Circuitry (Turquoise accents)
            const tubeGeometry = new THREE.TorusGeometry(0.6, 0.05, 16, 100);
            const tubeMaterial = new THREE.MeshStandardMaterial({ color: ACCENT_COLOR_A, metalness: 0.9, emissive: ACCENT_COLOR_A, emissiveIntensity: 1.2 });
            
            const tube1 = new THREE.Mesh(tubeGeometry, tubeMaterial);
            tube1.position.set(0, 3.5, 0);
            tube1.rotation.x = Math.PI / 2;
            towerGroup.add(tube1);

            const tube2 = tube1.clone();
            tube2.position.set(0, 0.5, 0);
            towerGroup.add(tube2);
            
            scene.add(towerGroup);


            // 3. Robot Arm Mechanism (Orange/Green - animated part)
            robotArmGroup = new THREE.Group();
            robotArmGroup.position.set(0, 4.0, 0); 
            towerGroup.add(robotArmGroup); 

            // Arm base (Orange)
            const armBaseGeometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const armBaseMaterial = new THREE.MeshStandardMaterial({ color: ACCENT_COLOR_B, metalness: 0.7, roughness: 0.3 });
            const armBase = new THREE.Mesh(armBaseGeometry, armBaseMaterial);
            robotArmGroup.add(armBase);

            // Arm segment 1 (The Green 'Brick')
            const segment1Geometry = new THREE.BoxGeometry(1.8, 0.5, 0.5); 
            const segment1Material = new THREE.MeshStandardMaterial({ color: GREEN_BRICK_COLOR, metalness: 0.4, roughness: 0.6 }); 
            const segment1 = new THREE.Mesh(segment1Geometry, segment1Material);
            segment1.position.set(0.9, 0, 0);
            robotArmGroup.add(segment1);
            
            // Arm segment 2 (Orange) - holding the claw
            const segment2Geometry = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
            const segment2Material = new THREE.MeshStandardMaterial({ color: ACCENT_COLOR_B, metalness: 0.7, roughness: 0.3 }); 
            const segment2 = new THREE.Mesh(segment2Geometry, segment2Material);
            segment2.position.set(1.9, 0, 0);
            segment2.rotation.z = Math.PI / 2;
            robotArmGroup.add(segment2);
            
            // Claw/Manipulator (Turquoise)
            const clawGeometry = new THREE.ConeGeometry(0.25, 0.5, 6);
            const clawMaterial = new THREE.MeshStandardMaterial({ color: ACCENT_COLOR_A, metalness: 0.9, roughness: 0.2 });
            const claw = new THREE.Mesh(clawGeometry, clawMaterial);
            claw.position.set(2.6, 0, 0);
            claw.rotation.z = -Math.PI / 2;
            robotArmGroup.add(claw);

            scene.userData.name = 'AutomataAltar';
        }

        /**
         * The function that exports the geometry to USDZ.
         */
        async function handleUSDZExport() {
            const exporter = new THREE.USDZExporter();
            const statusBox = document.getElementById('export-status');

            statusBox.textContent = 'Generating USDZ file (This can take a moment)...';
            statusBox.style.backgroundColor = '#cc7722'; // Orange Processing Color

            try {
                // Parse the entire scene object into a USDZ file (ArrayBuffer)
                const arraybuffer = await exporter.parseAsync(scene, { 
                    maxTextureSize: 1024,
                    includeAnchoringProperties: true, 
                    ar: { planeAnchoring: 'vertical' }
                });

                // Create a blob and trigger a download
                const blob = new Blob([arraybuffer], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);

                // Force download using a temporary link
                const link = document.createElement('a');
                link.href = url;
                link.download = 'Automata_Altar.usdz';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                statusBox.textContent = 'USDZ file generated and download started. Check your Downloads!';
                statusBox.style.backgroundColor = '#3CB371'; // Green Ready Color
                
            } catch (error) {
                console.error('USDZ Export failed:', error);
                statusBox.textContent = 'Export Failed. Failed to convert geometry.';
                statusBox.style.backgroundColor = '#cc4444'; // Red error color
            }
        }


        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Animation: Rotate the robot arm
            if (robotArmGroup) {
                robotArmGroup.rotation.y += 0.5 * delta; 
            }

            if (controls) controls.update(); 
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('scene-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Initialize the app on window load
        window.onload = init;
    </script>
</body>
</html>

